#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №7.Реализация потока обработки команад.

**Цель:** Реализовать основу для многопоточного сервера приложений.

**Результаты:** После выполнения работы Вы сможете:
1. Обрабатывать множество операций в несколько потоков.
2. Останавливать потоки по запросу извне.

## Задание.
Пусть операция задана интерфейсом

#!csharp

public interface ICommand
{
    void Execute();
}

#!markdown

Классы, наследующие интерйес ICommand будем называть **Командами.**

Реализовать класс ServerThread и команды по hard и soft завершению потока. 

ServerThread может менять свое поведение для обработки следующей Команды.
Исключение, выброшенное из Команды, перехватывается и передается вместе с самой Командой в ExceptionHandler (см. ЛР №5) Примечание. Наличие реализованного обработчика исключений не обязательно для выполнения данной задачи. 

Команда HardStop приводит к немедленной остановке потока, несмотря на, что в очереди потока есть еще Команды.
Команда  SoftStop останавливает поток, когда в очереди потока закончатся все Команды.

Команды HardStop и SoftStop успешно выполняются только в потоке, который они должны остановить, в противном случае выбрасывают исключение.
Отсутствие Команд в очереди потока не должно требовать значительных затрат процессорного времени. Значительными считаются затраты, которые зависят от времени простоя потока.

Написать проверку, которая гарантирует правильное выполнение команд HardStop и SoftStop.

#!csharp

using System.Threading;
using System.Collections.Concurrent;

class ServerThread
{
    public static ConcurrentQueue<ICommand> commandsQueue = new ConcurrentQueue<ICommand>();
    public static bool softStopRequested = false;
    public static void ThreadProcess()
    {
        while (true)
        {
            if (commandsQueue.TryDequeue(out var command))
            {
                try
                {
                    command.Execute();
                }
                catch (Exception e)
                {
                    if (e.Message == "Hard stop")
                    {
                        Console.WriteLine("Произошла жёсткая остановка потока");
                        break;
                    }
                    Console.WriteLine("Произошла ошибка");
                }
                
            }
            else if (softStopRequested == true)
                break;
        }
        Console.WriteLine("Поток завершён");
    }
}

static Thread myThread = new Thread(ServerThread.ThreadProcess);

class HardStop:ICommand
{
    public void Execute()
    {
        if (myThread.IsAlive)
            throw new Exception("Hard stop");
        else
            throw new Exception("Команда выполняется не в потоке");
    }
}

class SoftStop:ICommand
{
    public void Execute()
    {
        if (myThread.IsAlive)
        {
            Console.WriteLine("Запрошена мягкая остановка потока");
            ServerThread.softStopRequested = true;
        }
        else
            throw new Exception("Команда выполняется не в потоке");
    }
}

class Command:ICommand
{
    public void Execute()
    {
        Console.WriteLine("Какая-то команда выполнена");
    }
}

#!csharp

ServerThread.commandsQueue.Enqueue(new Command());
ServerThread.commandsQueue.Enqueue(new Command());
ServerThread.commandsQueue.Enqueue(new SoftStop());
ServerThread.commandsQueue.Enqueue(new Command());
ServerThread.commandsQueue.Enqueue(new Command());

myThread.Start();
myThread.Join();

#!csharp

myThread = new Thread(ServerThread.ThreadProcess);

ServerThread.commandsQueue.Enqueue(new Command());
ServerThread.commandsQueue.Enqueue(new Command());
ServerThread.commandsQueue.Enqueue(new HardStop());
ServerThread.commandsQueue.Enqueue(new Command());
ServerThread.commandsQueue.Enqueue(new Command());

myThread.Start();
myThread.Join();
